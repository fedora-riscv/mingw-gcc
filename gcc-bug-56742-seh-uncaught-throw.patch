--- a/gcc/config/i386/i386.c	
+++ a/gcc/config/i386/i386.c	
@@ -35564,6 +35564,35 @@ ix86_pad_short_function (void)
     }
 }
 
+/* Fix up a Windows system unwinder issue.  If an EH region falls thru into
+   the epilogue, the Windows system unwinder will apply epilogue logic and
+   produce incorrect offsets.  This can be avoided by adding a nop between
+   the last insn that can throw and the first insn of the epilogue.  */
+
+static void
+ix86_seh_fixup_eh_fallthru (void)
+{
+  edge e;
+  edge_iterator ei;
+
+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)
+    {
+      rtx insn = BB_END (e->src);
+
+      /* Find the beginning of the epilogue.  */
+      while (insn != NULL
+             && (!NOTE_P (insn)
+                 || NOTE_KIND (insn) != NOTE_INSN_EPILOGUE_BEG))
+	insn = PREV_INSN (insn);
+      if (insn == NULL)
+	continue;
+
+      insn = prev_active_insn (insn);
+      if (insn != NULL && can_throw_internal (insn))
+	emit_insn_after (gen_nops (const1_rtx), insn);
+    }
+}
+
 /* Implement machine specific optimizations.  We implement padding of returns
    for K8 CPUs and pass to avoid 4 jumps in the single 16 byte window.  */
 static void
@@ -35573,6 +35602,9 @@ ix86_reorg (void)
      with old MDEP_REORGS that are not CFG based.  Recompute it now.  */
   compute_bb_for_insn ();
 
+  if (TARGET_SEH && current_function_has_exception_handlers ())
+    ix86_seh_fixup_eh_fallthru ();
+
   if (optimize && optimize_function_for_speed_p (cfun))
     {
       if (TARGET_PAD_SHORT_FUNCTION)
